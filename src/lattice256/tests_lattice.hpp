/**
 *  Created by Jayamine Alupotha
 */

#ifndef CIP_SIS_TESTS_LATTICE_H
#define CIP_SIS_TESTS_LATTICE_H

const zint_t lattice_test_t0[N] = {2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2};

const zint_t lattice_test_t0128[N] = {(zint_t)("9223372036854775808"), (zint_t)("9223372036854775808"), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (zint_t)("9223372036854775808")};


const zint_t lattice_test_t1[N] = {4, 1, -1, -2, 4, -1, -1, 1, 4, 3, -1, -3, 3, 4, -1, 4, -1, 0, -2, 4, 0, 3, 2, 0, -2, -3, 1, -4, 2,
                                   2, 4, -1, -1, -3, -4, 2, 4, 4, 0, 1, 2, 2, 0, -1, -2, -1, -2, -2, -1, 4, 2, 2, -3, 0, 4, -1, 3, -1,
                                   3, -3, 2, -3, -4, -3, -1, 3, -3, -3, -3, -3, 0, 0, -1, 3, 2, 4, 1, 1, 2, 1, -1, 4, 1, 4, -2, 4, -4,
                                   3, 2, 1, 3, 0, 0, 2, 1, -4, -4, -3, 4, -1, 4, 1, 4, -1, -4, 4, 4, -1, -1, -2, -4, -4, -3, 3, 2, 2,
                                   -1, 1, -1, -2, 0, -4, -2, -2, -1, -4, 1, -2, 1, -2, 0, 3, 3, 1, 0, -3, -1, 3, -1, 4, 3, -1, 1, 2,
                                   4, -4, 4, 4, 1, 1, 0, -2, 1, 4, -2, 4, 1, 2, -4, 1, 0, -2, 0, -2, 2, 1, -3, -3, 3, 1, -2, 2, -3, 2,
                                   -2, -1, 0, -2, -1, 1, 4, 2, 3, 3, 2, 4, 0, -2, -2, 2, -3, -4, -3, 1, 3, -4, -4, -1, -4, 3, -3, -3,
                                   3, 0, 2, 3, 3, 1, 3, -1, -4, 0, 1, -2, 3, 0, -4, 2, 3, 0, 2, -4, 2, 0, 0, 3, -3, -1, -4, 4, 4, 2,
                                   1, 0, -4, 0, -1, 1, -1, -3, 2, -4, -1, -2, -4, 1, 3, 1, -1, 3, 3, 3, -2, -1, 2, 1};

const zint_t lattice_test_t2[N] = {-3, 1, -2, 4, -2, -1, 0, -2, 0, -1, -2, -1, 1, 0, -1, -3, 1, 3, -2, 0, 2, 4, -3, -2, -3, 2, 3, 2,
                                   -2, 3, -3, 0, 0, -1, -4, -4, -1, -3, 3, -1, 3, 1, -1, -1, -4, -1, 2, -2, 2, 2, -3, 4, 1, -4, 2, 3,
                                   -3, -4, -1, -4, 1, 4, 0, -1, 4, 1, -3, -4, -2, 1, -4, -4, 4, -3, 2, 2, -3, 0, 1, -2, -3, 2, 3, -2,
                                   3, -3, 2, 1, 0, 0, -1, 1, -3, 0, -3, -1, 3, 1, -2, -1, 2, 4, 0, 0, 3, 1, 0, 3, 2, -2, -3, 3, 4, 4,
                                   1, -1, -3, -4, -2, -1, -2, 0, -4, 1, 3, -2, 4, 1, -2, -3, 1, -1, -3, 1, -1, 3, -1, -3, 4, -2, -4,
                                   0, 3, -2, 0, 1, -2, -2, 0, 2, 3, 0, 2, -4, -1, -2, 2, -1, 4, 0, 4, -3, 2, 3, -1, 0, 0, 0, -4, 2,
                                   -2, 3, -3, -4, 0, 2, -3, -3, -1, 1, -2, 4, 3, 0, 0, 4, -2, 4, 3, 0, 4, 3, -4, 2, 4, -3, -3, 1, 3,
                                   0, -3, 3, -3, 1, -3, 1, -4, -2, 1, 2, 4, 0, -1, -2, -1, 0, -1, 1, 4, 3, -1, -3, 2, -1, -3, -4, 0,
                                   -4, 2, -2, 4, -2, 1, -1, -3, 1, -1, -4, 1, 0, -4, 3, -4, -4, 2, -2, 4, -4, 2, -4, 4, -3, -3, 3,
                                   -3, 4};

const zint_t lattice_test_t3[N] = {2, 0, -3, 1, -1, -1, -2, 1, 4, -1, 1, 1, -2, 1, 3, 4, 3, 2, -4, -2, -3, 0, 3, -3, -4, -2, 4, -3, 1,
                                   0, 1, -3, -2, -2, 2, -1, -2, -2, 4, -1, 1, -1, 0, 4, -4, 1, 4, 0, -1, 3, 3, 0, 0, -1, 1, -1, 2, -3,
                                   -2, 1, 0, -4, 3, -1, -4, -3, -4, 0, -1, -2, 0, -2, -2, 3, 0, -2, 0, -2, -2, 0, 0, 4, 0, 4, -4, -2,
                                   -3, 2, -3, -1, -2, -2, -2, -2, 4, 1, -4, 3, -2, -1, 1, 3, 4, 4, 1, -2, -2, 1, -4, 1, -1, 0, -4, -3,
                                   2, 3, -2, -3, -4, 1, 2, 2, -3, 3, 4, 1, -2, -4, -3, -4, -2, -4, 0, -1, -1, 4, -2, -2, -4, -1, 2,
                                   -1, 0, -2, -3, 1, 0, 4, 3, 4, 1, 0, -4, 1, -1, 3, -3, 4, -2, -4, 4, -4, 2, 4, 1, -2, 0, -1, 4, -2,
                                   -1, 0, 3, 1, 4, -4, -2, 4, -3, 0, -2, 3, -1, 2, 3, -1, 4, 4, -2, 2, 4, 4, 0, -1, 3, -1, -2, -3, -1,
                                   4, -1, 4, -1, 0, -2, -4, -2, 3, 4, 1, -1, 3, 3, 1, 3, -1, -1, 2, -3, 2, 0, -3, -1, 1, 0, -4, 4, 3,
                                   1, 4, -4, -4, -1, 1, -4, -1, 0, -2, -3, 0, -1, -3, 1, -3, 3, 0, 2, -3, -2, 2, -3, 0, 0, 2, -1, 1};

const zint_t lattice_test_out0[N] = {4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, 8};

const zint_t lattice_test_out1[N] = {255, -32, -227, -300, 9, -108, -207, 44, 183, 228, -38, -2, -25, 112, -154, 96, 75, 126, 66, 232,
                                     128, 218, 51, 14, 60, 28, -21, -116, 76, -108, -160, -438, 11, -70, 34, 46, 216, 126, 90, -200,
                                     -205, 118, 190, -136, -30, 186, -176, -24, 11, -60, 135, -120, -161, 160, -58, -70, -229, 120,
                                     256, 126, 138, -56, 160, -118, -229, 4, 21, -162, -20, -102, 150, 88, -14, 220, -185, -46, -207,
                                     60, 174, 72, -133, -200, -211, -38, 50, 250, 271, 188, 59, -6, 57, 240, -106, 34, 211, -64, 11,
                                     -6, -36, -172, 117, -38, 163, -24, 21, -208, -80, -76, -375, 120, 10, 6, -135, 162, 173, 174, -77,
                                     -114, 103, 96, 140, -38, 121, -154, 245, 94, -143, 52, 188, 78, -18, -146, -214, -170, -49, 72,
                                     73, -180, 36, 108, -118, 128, -219, 240, -138, -96, -174, 16, 19, -142, -42, -48, 131, 40, 102,
                                     -104, 377, -144, -64, 154, -52, 50, 67, 86, 39, 210, -34, -4, 215, 120, -48, 18, 189, -78, -91,
                                     -148, -40, 90, -167, -54, -48, 56, 16, 94, 12, 152, -38, 22, 133, 140, 382, 40, 72, 114, 46, -44,
                                     -79, 6, -158, -278, -114, -128, 3, -46, -48, -18, 5, 36, -111, -216, -310, -22, -176, 0, -31, 110,
                                     -182, -30, 171, 68, 243, 182, 255, -148, 3, 4, -107, -14, -173, 238, 90, 134, -13, 192, 284, -48,
                                     -12, 192, 183, 2, 11, -194, 37, -40, 169, 44, 69, -130, -145, -152, -119, -312, -173, 80, 91, 196};

const zint_t lattice_test_out2[N] = {-11, 221, -93, 26, -38, -202, 82, -85, 11, -88, 58, 104, -128, 13, 28, -19, -86, -66, -20, -50,
                                     80, 61, -73, 224, 83, -71, -32, 131, -261, 79, 27, 66, -61, 125, -105, -177, -19, 51, 78, -165,
                                     87, 50, -199, 107, -115, -103, 141, 47, -108, -112, -28, -23, -21, -23, 17, 72, -139, -165, -117,
                                     39, 67, -37, 104, 95, -96, 154, -54, 72, 26, 30, 7, 160, 76, -131, 80, 44, 61, -153, 5, -59, 60,
                                     -44, -31, -40, -37, -50, -3, -92, 92, 94, 177, 16, 67, -40, -72, 51, -100, -110, 163, 2, 104,
                                     -12, -92, -3, 134, -128, -63, 130, 15, -344, 165, -14, 16, -46, -41, -149, -65, -58, -27, -43,
                                     55, -1, 21, 40, 19, -162, -51, 136, 121, 2, -23, 91, -101, 3, 124, 63, -32, -19, 28, -195, 66,
                                     258, 43, 94, -43, -41, -4, -44, -129, 119, 108, 36, 127, -49, -114, 93, 41, -56, 124, 64, -29,
                                     51, -115, 201, 47, 45, 118, 45, -78, 33, -1, -138, 139, -44, 34, 133, 151, -67, -9, 58, 19, -115,
                                     -51, -74, 104, 144, -1, -49, 150, -36, -111, -231, -64, -17, 59, 142, -34, 221, 70, -147, 33, 94,
                                     -52, 27, 146, -14, 47, -13, 28, 73, 83, -13, 22, -88, -84, 59, -166, -77, -192, -104, -20, -162,
                                     -35, -132, -21, 55, -139, 23, 77, -21, -91, 43, 172, 36, -242, 97, -5, 144, -38, 99, -82, -11,
                                     -211, -152, 98, 22, 16, 30, -8, 68, -55, -174, 49, -7, -20, -45};



void test_reduce64() {
    zint_t gap = zint_t ("4951760157141521099596496896");
    CHECK(0 == reduceK1(0));
    CHECK(1 == reduceK1(1));
    CHECK(-1 == reduceK1(-1));
    CHECK(255 == reduceK1(255) && -6442450941 == reduceK1(-6442450941));
    CHECK( -Q2 - 1 + 17 != reduceK1(Q2 + 17));
    CHECK( Q2 + 1 -  17 != reduceK1(-Q2 - 17));
    //cout << " " << Q << " " << reduce64_exact(Q2 + 17) << "\n";
    CHECK( -Q2 - 1 + 17 == reduceK1_exact(Q2 + 17));
    CHECK( Q2 + 1 -  17 == reduceK1_exact(-Q2 - 17));
    CHECK( -Q2 - 1 + gap == reduceK1(Q2 + gap));
    CHECK( Q2 + 1 -  gap == reduceK1(-Q2 - gap));
    CHECK(0 == reduceK1(Q) && 0 == reduceK1(-Q));
    CHECK(1 == reduceK1(Q + 1) && 1 == reduceK1(-Q + 1));
    CHECK(-1 == reduceK1(Q - 1) && -1 == reduceK1(-Q - 1));
}


void test_check_norm() {
    poly a = poly_from_vec(lattice_test_t1);
    CHECK(poly_chknorm(&a, 5) == 0);
    poly b = poly_from_vec(lattice_test_out1);
    CHECK(poly_chknorm(&b, 382) != 0);
    poly c = poly_from_vec(lattice_test_out2);
    CHECK(poly_chknorm(&c, 345) == 0);
}


void test_get_masks() {
    int i, j;
    poly a[L], a_set[L];
    poly r, r_set;
    poly r1, r1_set;
    poly r2, r2_set;
    poly r3, r3_set;
    uint8_t a_seed[a_BYTES];
    uint8_t a_seedl[L][a_BYTES];
    uint8_t seed[r_BYTES];
    uint8_t seed1[r1_BYTES];
    uint8_t seed2[r2_BYTES];
    uint8_t seed3[r3_BYTES];
    poly b;

    for (i = 0; i < 100; i++) {
        tobinL(&b, i);
        get_alpha_mask(&a[0], a_seed, i % 2);
        set_alpha_mask(&a_set[0], a_seed);
        CHECK(poly_compare(&a[0], &a_set[0]) == 0);
        CHECK(poly_chknorm(&a[0], ALPHA) == 0);
        CHECK(poly_chknorm(&a[0], TAU) == -1);

        get_value_masks(a, a_seedl, &b);
        set_value_masks(a_set, a_seedl);
        for (j = 0; j < L; j++) {
            CHECK(poly_compare(&a[j], &a_set[j]) == 0);
            CHECK(poly_chknorm(&a[j], ALPHA) == 0);
            CHECK(poly_chknorm(&a[j], TAU) == -1);
        }
        CHECK(poly_L_chknorm(a, ALPHA) == 0);

        get_mask_tau(&r, seed);
        CHECK(poly_chknorm(&r, TAU) == 0);
        CHECK(poly_chknorm(&r, TAU1) == 0);
        set_mask_tau(&r_set, seed);
        CHECK(poly_compare(&r, &r_set) == 0);

        get_mask_tau1(&r1, seed1);
        CHECK(poly_chknorm(&r1, TAU1) == 0);
        set_mask_tau1(&r1_set, seed1);
        CHECK(poly_compare(&r1, &r1_set) == 0);

        get_mask_tau2(&r2, seed2);
        CHECK(poly_chknorm(&r2, TAU2) == 0);
        CHECK(poly_chknorm(&r2, TAU) == -1);
        CHECK(poly_chknorm(&r2, TAU1) == -1);
        set_mask_tau2(&r2_set, seed2);
        CHECK(poly_compare(&r2, &r2_set) == 0);

        get_mask_tau3(&r3, seed3);
        CHECK(poly_chknorm(&r3, TAU3) == 0);
        CHECK(poly_chknorm(&r3, TAU) == -1);
        CHECK(poly_chknorm(&r3, TAU1) == -1);
        set_mask_tau3(&r3_set, seed3);
        CHECK(poly_compare(&r3, &r3_set) == 0);

        uint L1 = 20;
        zint_t MAX = ((zint_t)1 << L1);
        zint_t range = (((zint_t)1 << (L1 + EXTRA_BITS)));
        get_alpha1_mask(&a[0], i, L1);
        CHECK(poly_chknorm(&a[0], range) == 0);
    }

}

void test_challenge_poly() {
    poly x;
    uint8_t h[SEED_BYTES];
    int i, j, count;

    for (i = 0; i < 16; i++) {
        memset(h, i, SEED_BYTES);
        poly_challenge(&x, h);
        count = 0;
        for (j = 0; j < N; j++) {
            CHECK(x.coef[j] == 0 || x.coef[j] == 1 || x.coef[j] == -1);
            if (x.coef[j] != 0) {
                count++;
            }
        }
        CHECK(count == BETA);
    }
}

void test_pack() {
    int i;
    poly a_expected = poly_from_vec(lattice_test_out2);
    poly a = poly_from_vec(lattice_test_out2);

    uint8_t buffer[u_BYTES];
    pack_custom_poly(buffer, &a);
    unpack_custom_poly(&a, buffer);

    CHECK(poly_compare(&a_expected, &a) == 0);

    // make large coefficients
    for (i = 0; i < N; i++) {
        a.coef[i] = a.coef[i] * 140737488355327 + i; // 2^47 - 1
        a_expected.coef[i] = a.coef[i];
    }

    poly_reduce_exact(&a);
    poly_reduce_exact(&a_expected);

    pack_custom_poly(buffer, &a);
    unpack_custom_poly(&a, buffer);

    CHECK(poly_compare(&a_expected, &a) == 0);

    poly_n u;
    poly_n u_expected;
    for (i = 0; i < n; i++) {
        u.vec[i] = a;
        u_expected.vec[i] = a_expected;
    }

    uint8_t buffer_n[n * u_BYTES];
    pack_poly_ring(buffer_n, &u);
    unpack_poly_ring(&u, buffer_n);

    CHECK(poly_n_compare(&u_expected, &u) == 0);

    poly b;
    tobinL(&b, (zint_t) GAMMA1);
    uint8_t a_seedl[L][a_BYTES];
    uint8_t buffer_a[z_BYTES];
    poly al[L];
    poly al_expected[L];
    get_value_masks(al, a_seedl, &b);
    set_value_masks(al_expected, a_seedl);
    for (i = 0; i < L; i++) {
        CHECK(poly_compare(&al_expected[i], &al[i]) == 0);
    }
    pack_poly_z(buffer_a, al);
    unpack_poly_z(al, buffer_a);

    for (i = 0; i < L; i++) {
        CHECK(poly_compare(&al_expected[i], &al[i]) == 0);
    }

    uint8_t r2_seed[m - D][r2_BYTES];
    uint8_t buffer_r2[R_BYTES];
    poly R2[m - D];
    poly R_expected[m - D];
    for (i = 0; i < m - D; i++) {
        poly_set_zero(&R2[i], 0, N);
        poly_set_zero(&R_expected[i], 0, N);
        get_mask_tau2(&R2[i], r2_seed[i]);
        set_mask_tau2(&R_expected[i], r2_seed[i]);
        CHECK(poly_compare(&R_expected[i], &R2[i]) == 0);
    }

    pack_poly_m_R(buffer_r2, R2);
    unpack_poly_m_R(R2, buffer_r2);

    for (i = 0; i < m - D; i++) {
        CHECK(poly_compare(&R_expected[i], &R2[i]) == 0);
    }

    uint8_t r3_seed[m - D][r3_BYTES];
    uint8_t buffer_r3[sig_BYTES];
    poly sigma[m - D];
    poly sigma_expected[m - D];
    for (i = 0; i < m - D; i++) {
        poly_set_zero(&sigma[i], 0, N);
        poly_set_zero(&sigma_expected[i], 0, N);
        get_mask_tau3(&sigma[i], r3_seed[i]);
        set_mask_tau3(&sigma_expected[i], r3_seed[i]);
        CHECK(poly_compare(&sigma_expected[i], &sigma[i]) == 0);
    }

    pack_poly_sig(buffer_r3, sigma);
    unpack_poly_sig(sigma, buffer_r3);

    for (i = 0; i < m - D; i++) {
        CHECK(poly_compare(&sigma_expected[i], &sigma[i]) == 0);
    }
}


/**
 * Test ntt correctness with Dilithium outputs where all polynomials are less than 2^23 - 2^13 + 1.
 */
void test_ntt() {
    int i;

    poly a = poly_from_vec(lattice_test_t0128);
    poly_reduce(&a);
    poly a_returned = poly_from_vec(lattice_test_t0128);
    poly_ntt(&a_returned);
    poly_inv_ntt(&a_returned);
    poly_reduce(&a_returned);
    CHECK(poly_compare(&a_returned, &a) == 0);

    a = poly_from_vec(lattice_test_t0);
    poly_ntt(&a);
    poly out0_expected = poly_from_vec(lattice_test_out0);
    poly out0_returned;
    poly_pointwise_montgomery(&out0_returned, &a, &a);
    poly_inv_ntt_to_mont(&out0_returned);
    poly_reduce(&out0_returned);
    //for (i = 0; i < N; i++) cout << out0_returned.coef[i] << " " << out0_expected.coef[i]  << "\n";
    CHECK(poly_compare(&out0_returned, &out0_expected) == 0);

    a = poly_from_vec(lattice_test_t1);
    poly b = poly_from_vec(lattice_test_t1);
    poly_ntt(&a);
    poly out1_expected = poly_from_vec(lattice_test_out1);
    poly out1_returned;
    poly_pointwise_montgomery(&out1_returned, &a, &a);
    poly_inv_ntt_to_mont(&out1_returned);
    poly_inv_ntt(&a);
    poly_reduce(&a);
    poly_reduce(&out1_returned);

    CHECK(poly_compare(&a, &b) == 0);
    CHECK(poly_compare(&out1_returned, &out1_expected) == 0);

    poly c = poly_from_vec(lattice_test_t2);
    poly d = poly_from_vec(lattice_test_t3);
    poly_ntt(&c);
    poly_ntt(&d);
    poly out2_expected = poly_from_vec(lattice_test_out2);
    poly out2_returned;
    poly_pointwise_montgomery(&out2_returned, &c, &d);
    poly_inv_ntt_to_mont(&out2_returned);
    poly_inv_ntt(&c);
    poly_inv_ntt(&d);
    poly_reduce(&out2_returned);
    poly_reduce(&c);
    poly_reduce(&d);

    CHECK(poly_compare(&out2_returned, &out2_expected) == 0);
    poly tmp = poly_from_vec(lattice_test_t2);
    CHECK(poly_compare(&c, &tmp) == 0);
    tmp = poly_from_vec(lattice_test_t3);
    CHECK(poly_compare(&d, &tmp) == 0);

    for (i = 0; i < N; i++) {
        c.coef[i] <<= 10;
        d.coef[i] <<= 44;
        out2_expected.coef[i] <<= 54;  // Maximum is 2^55. because the montgomery factor is 2^55
    }
    poly_ntt(&c);
    poly_ntt(&d);
    poly_pointwise_montgomery(&out2_returned, &c, &d);
    poly_inv_ntt_to_mont(&out2_returned);
    poly_reduce_exact(&out2_returned);
    poly_reduce_exact(&out2_expected);

    CHECK(poly_compare(&out2_returned, &out2_expected) == 0);
}


void test_matrix_mul() {
    uint8_t ctx_seed[SEED_BYTES];
    RAND_bytes(ctx_seed, SEED_BYTES);
    context_t ctx = init(ctx_seed);
    uint8_t seed[r_BYTES];
    int i;

    poly_m s;
    poly_m s1;
    poly_m s2;
    poly_m_set_zero(&s1, 0, N);
    poly_m_set_zero(&s2, 0, N);
    for(i = 0; i < m; i++) get_mask_tau(&s1.vec[i], seed);
    for(i = 0; i < m; i++) get_mask_tau(&s2.vec[i], seed);

    poly_n A;
    poly_n B;
    poly_n C;
    poly_n U;
    poly_m_ntt(&s1);
    poly_m_ntt(&s2);
    poly_matrix_mul(&A, ctx.H, &s1);
    poly_matrix_mul(&B, ctx.H, &s2);
    poly_m_add(&s, &s1, &s2);
    poly_matrix_mul(&C, ctx.H, &s);

    poly_n_add(&U, &A, &B);
    poly_n_reduce_exact(&U);
    poly_n_reduce_exact(&C);
    CHECK(poly_n_compare(&U, &C) == 0);

    poly_m s11;
    poly_m s21;

    poly_m_set_zero(&s1, 0, N);
    poly_m_set_zero(&s2, 0, N);
    for(i = 0; i < m; i++) {get_mask_tau(&s1.vec[i], seed); poly_set(&s11.vec[i], &s1.vec[i]);}
    for(i = 0; i < m; i++) {get_mask_tau(&s2.vec[i], seed); poly_set(&s21.vec[i], &s2.vec[i]);}

    CHECK(poly_m_compare(&s1, &s11) == 0);
    CHECK(poly_m_compare(&s2, &s21) == 0);
    poly_m_add(&s, &s1, &s2);
    poly_m_ntt(&s1);
    poly_m_ntt(&s2);
    poly_m_inv_ntt(&s1);
    poly_m_inv_ntt(&s2);
    poly_m_reduce_exact(&s1);
    poly_m_reduce_exact(&s2);
    CHECK( poly_m_compare(&s1, &s11) == 0);
    CHECK(poly_m_compare(&s2, &s21) == 0);

    poly_matrix_mul(&A, ctx.H, &s1);
    poly_matrix_mul(&B, ctx.H, &s2);
    poly_matrix_mul(&C, ctx.H, &s);

    poly_n_add(&U, &A, &B);
    poly_n_reduce_exact(&U);
    poly_n_reduce_exact(&C);
    CHECK(poly_n_compare(&U, &C) == 0);

    poly_n LHS;
    poly_n RHS;
    poly one;
    poly_set_zero(&one, 0, N);
    one.coef[0] = 2;
    poly_ntt(&one);

    for(i = 0; i < m; i++) {get_mask_tau(&s.vec[i], seed);}
    poly_m_ntt(&s);
    poly_matrix_mul(&RHS, ctx.H, &s);
    poly_n_ntt(&RHS);
    poly_n_pointwise_montgomery(&RHS, &RHS, &one);
    poly_n_inv_ntt_to_mont(&RHS);
    poly_n_reduce_exact(&RHS);


    poly_m_pointwise_montgomery(&s, &s, &one);
    poly_m_inv_ntt_to_mont(&s);
    poly_m_reduce_exact(&s);
    poly_m_ntt(&s);
    poly_matrix_mul(&LHS, ctx.H, &s);

    CHECK(poly_n_compare(&LHS, &RHS) == 0);
}


#endif //CIP_SIS_TESTS_LATTICE_H
